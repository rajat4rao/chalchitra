# ChalChitra - Movie & TV Show Discovery Platform powered by AI

[![License: ISC](https://img.shields.io/badge/License-ISC-blue.svg)](https://opensource.org/licenses/ISC)

**ChalChitra** is a full-stack application designed for discovering movies and TV shows. Users can explore trending content, search for specific titles, manage their personalized lists, and get AI-powered recommendations.

---

**[[Live Demo Link]](https://chalchitra1.netlify.app/)** 
---

---

## Overview

ChalChitra provides a seamless experience for movie and TV enthusiasts. Built with the MERN stack (MongoDB, Express.js, React, Node.js), it integrates with the TMDB API for comprehensive media data and leverages the Groq API (using Llama models) to offer intelligent recommendations. User authentication is handled securely using JWT and bcryptjs. The frontend, built with React and Vite, features a responsive design styled with Tailwind CSS and utilizes Cloudinary for user avatar management.

## Key Features

*   **User Authentication:** Secure registration and login using JWT and bcryptjs for password hashing.
*   **Personalized Profiles:** Users can create profiles, upload avatars (via Cloudinary), and maintain lists of their favorite movies and TV shows.
*   **TMDB Integration:** Browse extensive movie and TV show data, including:
    *   Top Rated, Popular, Trending, Upcoming, Now Playing lists.
    *   Detailed information pages for individual movies/shows (overview, cast, genres, ratings, seasons/episodes for TV).
    *   Recommendations for similar titles based on user profile data (requires login).
*   **AI-Powered Recommendations:** Unique feature allowing users to select up to 25 movies/shows and receive 10 tailored recommendations generated by a Llama model via the Groq API.
*   **Search Functionality:** Real-time search for movies and TV shows with type filtering.
*   **Add/Remove Functionality:** Easily add or remove items from the user's profile list directly from item cards or detail pages.
*   **Responsive Design:** User interface adapts gracefully to different screen sizes using Tailwind CSS.
*   **Modern Frontend:** Built with React & Vite, featuring smooth animations (`react-awesome-reveal`), context API for state management, and accessible UI components (`@headlessui/react`).

## Technology Stack

**Frontend:**
*   React.js (v18)
*   Vite (Build Tool)
*   Tailwind CSS (v3)
*   React Router DOM (v6)
*   React Context API
*   Headless UI
*   React Icons
*   Splide.js (for sliders)
*   Groq SDK (AI Integration)
*   Cloudinary React SDK (Image Uploads)
*   Emotion (Styling - dependency of react-awesome-reveal)

**Backend:**
*   Node.js
*   Express.js
*   MongoDB Atlas (Database)
*   Mongoose (ODM)
*   JSON Web Token (jsonwebtoken) (Authentication)
*   bcryptjs (Password Hashing)
*   CORS
*   dotenv (Environment Variables)

**APIs:**
*   TMDB API (Movie/TV Data)
*   Groq API (Llama AI Models)
*   Cloudinary API (Image Hosting)

**Development Tools:**
*   Nodemon (Backend Auto-Reload)
*   ESLint (Code Linting)
*   REST Client / Postman (API Testing)

## Architecture

ChalChitra follows a standard MERN stack architecture:

1.  **Client (React/Vite):** Handles the user interface, state management, and user interactions. It communicates with the backend API for data persistence and authentication. It also directly interacts with TMDB, Groq, and Cloudinary APIs using keys securely stored in environment variables.
2.  **Backend (Node/Express):** A RESTful API serves as the intermediary between the client and the database. It handles business logic, user authentication (JWT verification, password hashing), and CRUD operations for user profiles and lists via Mongoose.
3.  **Database (MongoDB):** Stores user credentials (hashed passwords), profile information (username, avatar URL), and lists of saved movie/TV IDs.

Authentication Flow:
*   User registers/logins via the backend API.
*   On successful login, the backend generates a JWT containing user ID and sends it to the client.
*   The client stores the JWT (and user ID) in Local Storage.
*   Subsequent authenticated requests from the client include the JWT in the request (likely via `POST /auth` for verification or potentially an Authorization header - *clarify if needed*), which the backend validates before processing.

## API Endpoints (Backend - `/api`)

The backend exposes the following REST endpoints:

*   `GET /`: Basic API status check.
*   `POST /auth/register`: Creates a new user. Requires `username`, `password`, `avatar` (URL).
*   `POST /auth/login`: Authenticates a user. Requires `username`, `password`. Returns `userId` and `token`.
*   `POST /auth`: Verifies an existing token. Requires `id`, `token`. Returns `isAuth: true/false`.
*   `POST /auth/usercheck`: Checks if a username already exists during registration. Requires `username`.
*   `GET /user/:id`: Retrieves user profile data (username, avatar, movie IDs, tv IDs).
*   `GET /user/:id/:type`: Retrieves specific list (`movies` or `tv` or `all`) for a user.
*   `POST /user/:id/additem`: Adds or removes a movie/TV show ID from a user's list. Requires `type` (`movie` or `tv`) and `itemid`. Toggles presence.

*(See `api/request.REST` for example usage)*

## Getting Started

To run this project locally:

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/your-username/chalchitra-main.git
    cd chalchitra-main
    ```

2.  **Install Root Dependencies (if any):**
    ```bash
    # Check chalchitra-main/package.json if needed, otherwise skip
    # npm install
    ```

3.  **Setup Backend (`/api`):**
    *   Navigate to the API directory:
        ```bash
        cd api
        ```
    *   Install dependencies:
        ```bash
        npm install
        ```
    *   Create a `.env` file in the `/api` directory and add the following environment variables:
        ```env
        DATABASE_URL=your_mongodb_connection_string
        JWT_SECRET=your_strong_jwt_secret_key
        PORT=3000 # Or any port you prefer
        ```
    *   Run the backend server (development mode):
        ```bash
        npm run dev
        ```
        The API should now be running on `http://localhost:3000` (or your specified port).

4.  **Setup Frontend (`/client`):**
    *   Navigate to the client directory from the root:
        ```bash
        cd ../client
        ```
    *   Install dependencies:
        ```bash
        npm install
        ```
    *   Create a `.env` file in the `/client` directory and add the following environment variables:
        ```env
        VITE_DB_API_BASE_URL=http://localhost:3000 # Backend API URL
        VITE_TMDB_ACCESS=your_tmdb_api_access_token
        VITE_AI_KEY=your_groq_api_key
        VITE_CLOUDINARY_PRESET=your_cloudinary_upload_preset
        VITE_CLOUDINARY_CLOUD=your_cloudinary_cloud_name
        ```
        *   Get TMDB API Access Token [here](https://www.themoviedb.org/settings/api).
        *   Get Groq API Key [here](https://console.groq.com/keys).
        *   Get Cloudinary details [here](https://cloudinary.com/).
    *   Run the frontend development server:
        ```bash
        npm run dev
        ```
        The application should now be running, typically on `http://localhost:5173`.

## Environment Variables

Make sure to create `.env` files in both the `/api` and `/client` directories with the following variables:

**`/api/.env`**

*   `DATABASE_URL`: Your MongoDB connection string.
*   `JWT_SECRET`: A strong, unique secret key for signing JWTs.
*   `PORT`: (Optional) Port for the backend server (defaults if not set, often 3000).

**`/client/.env`**

*   `VITE_DB_API_BASE_URL`: The full URL where your backend API is running (e.g., `http://localhost:3000`).
*   `VITE_TMDB_ACCESS`: Your TMDB API Access Token (Bearer Token).
*   `VITE_AI_KEY`: Your Groq API Key.
*   `VITE_CLOUDINARY_PRESET`: Your Cloudinary upload preset name.
*   `VITE_CLOUDINARY_CLOUD`: Your Cloudinary cloud name.

**_Note:_ Never commit your `.env` files to version control!** Ensure `.env` is included in your `.gitignore` file.

## Future Improvements

*   Implement user ratings and reviews for movies/shows.
*   Add social features like following users and seeing friends' lists.
*   More detailed user statistics and viewing history.
*   Implement pagination or infinite scrolling for longer lists in the profile.
*   Add unit and integration tests for backend and frontend components.
*   Potential migration to TypeScript for enhanced type safety.
